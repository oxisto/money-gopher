package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.61

import (
	"context"
	"slices"

	"github.com/oxisto/money-gopher/db"
	"github.com/oxisto/money-gopher/graph/model"
)

// Security is the resolver for the security field.
func (r *listedSecurityResolver) Security(ctx context.Context, obj *db.ListedSecurity) (*db.Security, error) {
	return r.Queries.GetSecurity(ctx, obj.SecurityID)
}

// CreateSecurity is the resolver for the createSecurity field.
func (r *mutationResolver) CreateSecurity(ctx context.Context, input model.SecurityInput) (*db.Security, error) {
	return withTx(r.Resolver, func(qtx *db.Queries) (*db.Security, error) {
		sec, err := qtx.CreateSecurity(ctx, db.CreateSecurityParams{
			ID:          input.ID,
			DisplayName: input.DisplayName,
		})
		if err != nil {
			return nil, err
		}

		for _, listed := range input.ListedAs {
			_, err = qtx.UpsertListedSecurity(ctx, db.UpsertListedSecurityParams{
				SecurityID: sec.ID,
				Ticker:     listed.Ticker,
				Currency:   listed.Currency,
			})
			if err != nil {
				return nil, err
			}
		}

		return sec, nil
	})
}

// UpdateSecurity is the resolver for the updateSecurity field.
func (r *mutationResolver) UpdateSecurity(ctx context.Context, id string, input model.SecurityInput) (*db.Security, error) {
	return withTx(r.Resolver, func(qtx *db.Queries) (*db.Security, error) {
		sec, err := qtx.UpdateSecurity(ctx, db.UpdateSecurityParams{
			ID:          id,
			DisplayName: input.DisplayName,
		})
		if err != nil {
			return nil, err
		}

		// Retrieve old listed securities
		oldListed, err := qtx.ListListedSecuritiesBySecurityID(ctx, id)
		if err != nil {
			return nil, err
		}

		// Upsert the new listed securities
		for _, listed := range input.ListedAs {
			_, err = qtx.UpsertListedSecurity(ctx, db.UpsertListedSecurityParams{
				SecurityID: sec.ID,
				Ticker:     listed.Ticker,
				Currency:   listed.Currency,
			})
			if err != nil {
				return nil, err
			}

			// Remove the listed security from the old list
			oldListed = slices.DeleteFunc(oldListed, func(ls *db.ListedSecurity) bool {
				return ls.Ticker == listed.Ticker
			})
		}

		// Remove the old listed securities
		for _, old := range oldListed {
			_, err = qtx.DeleteListedSecurity(ctx, db.DeleteListedSecurityParams{
				SecurityID: sec.ID,
				Ticker:     old.Ticker,
			})
			if err != nil {
				return nil, err
			}
		}

		return sec, nil
	})
}

// Security is the resolver for the security field.
func (r *queryResolver) Security(ctx context.Context, id string) (*db.Security, error) {
	return r.Queries.GetSecurity(ctx, id)
}

// Securities is the resolver for the securities field.
func (r *queryResolver) Securities(ctx context.Context) ([]*db.Security, error) {
	return r.Queries.ListSecurities(ctx)
}

// QuoteProvider is the resolver for the quoteProvider field.
func (r *securityResolver) QuoteProvider(ctx context.Context, obj *db.Security) (*string, error) {
	if obj.QuoteProvider.Valid {
		return &obj.QuoteProvider.String, nil
	}

	return nil, nil
}

// ListedAs is the resolver for the listedAs field.
func (r *securityResolver) ListedAs(ctx context.Context, obj *db.Security) ([]*db.ListedSecurity, error) {
	return r.Queries.ListListedSecuritiesBySecurityID(ctx, obj.ID)
}

// ListedSecurity returns ListedSecurityResolver implementation.
func (r *Resolver) ListedSecurity() ListedSecurityResolver { return &listedSecurityResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Security returns SecurityResolver implementation.
func (r *Resolver) Security() SecurityResolver { return &securityResolver{r} }

type listedSecurityResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type securityResolver struct{ *Resolver }
