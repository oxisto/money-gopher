package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.61

import (
	"context"
	"database/sql"
	"fmt"
	"slices"
	"time"

	"github.com/oxisto/money-gopher/finance"
	"github.com/oxisto/money-gopher/models"
	"github.com/oxisto/money-gopher/persistence"
)

// ReferenceAccount is the resolver for the referenceAccount field.
func (r *accountResolver) ReferenceAccount(ctx context.Context, obj *persistence.Account) (*persistence.Account, error) {
	panic(fmt.Errorf("not implemented: ReferenceAccount - referenceAccount"))
}

// Security is the resolver for the security field.
func (r *listedSecurityResolver) Security(ctx context.Context, obj *persistence.ListedSecurity) (*persistence.Security, error) {
	panic(fmt.Errorf("not implemented: Security - security"))
}

// LatestQuoteTimestamp is the resolver for the latestQuoteTimestamp field.
func (r *listedSecurityResolver) LatestQuoteTimestamp(ctx context.Context, obj *persistence.ListedSecurity) (*string, error) {
	panic(fmt.Errorf("not implemented: LatestQuoteTimestamp - latestQuoteTimestamp"))
}

// CreateSecurity is the resolver for the createSecurity field.
func (r *mutationResolver) CreateSecurity(ctx context.Context, input models.SecurityInput) (*persistence.Security, error) {
	return withTx(r.Resolver, func(qtx *persistence.Queries) (*persistence.Security, error) {
		sec, err := qtx.CreateSecurity(ctx, persistence.CreateSecurityParams{
			ID:          input.ID,
			DisplayName: input.DisplayName,
		})
		if err != nil {
			return nil, err
		}

		for _, listed := range input.ListedAs {
			_, err = qtx.UpsertListedSecurity(ctx, persistence.UpsertListedSecurityParams{
				SecurityID: sec.ID,
				Ticker:     listed.Ticker,
				Currency:   listed.Currency,
			})
			if err != nil {
				return nil, err
			}
		}

		return sec, nil
	})
}

// UpdateSecurity is the resolver for the updateSecurity field.
func (r *mutationResolver) UpdateSecurity(ctx context.Context, id string, input models.SecurityInput) (*persistence.Security, error) {
	return withTx(r.Resolver, func(qtx *persistence.Queries) (*persistence.Security, error) {
		sec, err := qtx.UpdateSecurity(ctx, persistence.UpdateSecurityParams{
			ID:          id,
			DisplayName: input.DisplayName,
		})
		if err != nil {
			return nil, err
		}

		// Retrieve old listed securities
		oldListed, err := qtx.ListListedSecuritiesBySecurityID(ctx, id)
		if err != nil {
			return nil, err
		}

		// Upsert the new listed securities
		for _, listed := range input.ListedAs {
			_, err = qtx.UpsertListedSecurity(ctx, persistence.UpsertListedSecurityParams{
				SecurityID: sec.ID,
				Ticker:     listed.Ticker,
				Currency:   listed.Currency,
			})
			if err != nil {
				return nil, err
			}

			// Remove the listed security from the old list
			oldListed = slices.DeleteFunc(oldListed, func(ls *persistence.ListedSecurity) bool {
				return ls.Ticker == listed.Ticker
			})
		}

		// Remove the old listed securities
		for _, old := range oldListed {
			_, err = qtx.DeleteListedSecurity(ctx, persistence.DeleteListedSecurityParams{
				SecurityID: sec.ID,
				Ticker:     old.Ticker,
			})
			if err != nil {
				return nil, err
			}
		}

		return sec, nil
	})
}

// CreatePortfolio is the resolver for the createPortfolio field.
func (r *mutationResolver) CreatePortfolio(ctx context.Context, input models.PortfolioInput) (*persistence.Portfolio, error) {
	return withTx(r.Resolver, func(qtx *persistence.Queries) (*persistence.Portfolio, error) {
		sec, err := qtx.CreatePortfolio(ctx, persistence.CreatePortfolioParams{
			ID:          input.ID,
			DisplayName: input.DisplayName,
		})
		if err != nil {
			return nil, err
		}

		for _, accountID := range input.AccountIds {
			err = qtx.AddAccountToPortfolio(ctx, persistence.AddAccountToPortfolioParams{
				PortfolioID: input.ID,
				AccountID:   accountID,
			})
			if err != nil {
				return nil, err
			}
		}

		return sec, nil
	})
}

// UpdatePortfolio is the resolver for the updatePortfolio field.
func (r *mutationResolver) UpdatePortfolio(ctx context.Context, id string, input models.PortfolioInput) (*persistence.Portfolio, error) {
	return withTx(r.Resolver, func(qtx *persistence.Queries) (*persistence.Portfolio, error) {
		sec, err := qtx.UpdatePortfolio(ctx, persistence.UpdatePortfolioParams{
			ID:          input.ID,
			DisplayName: input.DisplayName,
		})
		if err != nil {
			return nil, err
		}

		for _, accountID := range input.AccountIds {
			err = qtx.AddAccountToPortfolio(ctx, persistence.AddAccountToPortfolioParams{
				PortfolioID: input.ID,
				AccountID:   accountID,
			})
			if err != nil {
				return nil, err
			}
		}

		return sec, nil
	})
}

// CreateAccount is the resolver for the createAccount field.
func (r *mutationResolver) CreateAccount(ctx context.Context, input models.AccountInput) (*persistence.Account, error) {
	return r.DB.CreateAccount(ctx, persistence.CreateAccountParams{
		ID:          input.ID,
		DisplayName: input.DisplayName,
		Type:        input.Type,
	})
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, id string) (*persistence.Account, error) {
	return r.DB.DeleteAccount(ctx, id)
}

// TriggerQuoteUpdate is the resolver for the triggerQuoteUpdate field.
func (r *mutationResolver) TriggerQuoteUpdate(ctx context.Context, securityIDs []string) (updated []*persistence.ListedSecurity, err error) {
	updated, err = r.QuoteUpdater.UpdateQuotes(ctx, securityIDs)
	if err != nil {
		return nil, err
	}

	return
}

// Accounts is the resolver for the accounts field.
func (r *portfolioResolver) Accounts(ctx context.Context, obj *persistence.Portfolio) ([]*persistence.Account, error) {
	return r.DB.ListAccountsByPortfolioID(ctx, obj.ID)
}

// Snapshot is the resolver for the snapshot field.
func (r *portfolioResolver) Snapshot(ctx context.Context, obj *persistence.Portfolio, when string) (snap *models.PortfolioSnapshot, err error) {
	var t time.Time

	if when == "" {
		t = time.Now()
	} else {
		t, err = time.Parse(time.RFC3339, when)
		if err != nil {
			return nil, err
		}
	}

	return finance.BuildSnapshot(ctx, t, obj.ID, r.DB)
}

// Events is the resolver for the events field.
func (r *portfolioResolver) Events(ctx context.Context, obj *persistence.Portfolio) ([]*models.PortfolioEvent, error) {
	panic(fmt.Errorf("not implemented: Events - events"))
}

// Security is the resolver for the security field.
func (r *queryResolver) Security(ctx context.Context, id string) (*persistence.Security, error) {
	return r.DB.GetSecurity(ctx, id)
}

// Securities is the resolver for the securities field.
func (r *queryResolver) Securities(ctx context.Context) ([]*persistence.Security, error) {
	return r.DB.ListSecurities(ctx)
}

// Portfolio is the resolver for the portfolio field.
func (r *queryResolver) Portfolio(ctx context.Context, id string) (*persistence.Portfolio, error) {
	return r.DB.GetPortfolio(ctx, id)
}

// Portfolios is the resolver for the portfolios field.
func (r *queryResolver) Portfolios(ctx context.Context) ([]*persistence.Portfolio, error) {
	return r.DB.ListPortfolios(ctx)
}

// Account is the resolver for the account field.
func (r *queryResolver) Account(ctx context.Context, id string) (*persistence.Account, error) {
	return r.DB.GetAccount(ctx, id)
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context) ([]*persistence.Account, error) {
	return r.DB.ListAccounts(ctx)
}

// Transactions is the resolver for the transactions field.
func (r *queryResolver) Transactions(ctx context.Context, accountID string) ([]*persistence.Transaction, error) {
	return r.DB.ListTransactionsByAccountID(ctx, sql.NullString{String: accountID, Valid: true})
}

// QuoteProvider is the resolver for the quoteProvider field.
func (r *securityResolver) QuoteProvider(ctx context.Context, obj *persistence.Security) (*string, error) {
	if obj.QuoteProvider.Valid {
		return &obj.QuoteProvider.String, nil
	}

	return nil, nil
}

// ListedAs is the resolver for the listedAs field.
func (r *securityResolver) ListedAs(ctx context.Context, obj *persistence.Security) ([]*persistence.ListedSecurity, error) {
	return obj.ListedAs(ctx, r.DB)
}

// Time is the resolver for the time field.
func (r *transactionResolver) Time(ctx context.Context, obj *persistence.Transaction) (string, error) {
	return obj.Time.Format(time.RFC3339), nil
}

// SourceAccount is the resolver for the sourceAccount field.
func (r *transactionResolver) SourceAccount(ctx context.Context, obj *persistence.Transaction) (*persistence.Account, error) {
	panic(fmt.Errorf("not implemented: SourceAccount - sourceAccount"))
}

// DestinationAccount is the resolver for the destinationAccount field.
func (r *transactionResolver) DestinationAccount(ctx context.Context, obj *persistence.Transaction) (*persistence.Account, error) {
	panic(fmt.Errorf("not implemented: DestinationAccount - destinationAccount"))
}

// Security is the resolver for the security field.
func (r *transactionResolver) Security(ctx context.Context, obj *persistence.Transaction) (*persistence.Security, error) {
	panic(fmt.Errorf("not implemented: Security - security"))
}

// Account returns AccountResolver implementation.
func (r *Resolver) Account() AccountResolver { return &accountResolver{r} }

// ListedSecurity returns ListedSecurityResolver implementation.
func (r *Resolver) ListedSecurity() ListedSecurityResolver { return &listedSecurityResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Portfolio returns PortfolioResolver implementation.
func (r *Resolver) Portfolio() PortfolioResolver { return &portfolioResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Security returns SecurityResolver implementation.
func (r *Resolver) Security() SecurityResolver { return &securityResolver{r} }

// Transaction returns TransactionResolver implementation.
func (r *Resolver) Transaction() TransactionResolver { return &transactionResolver{r} }

type accountResolver struct{ *Resolver }
type listedSecurityResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type portfolioResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type securityResolver struct{ *Resolver }
type transactionResolver struct{ *Resolver }
