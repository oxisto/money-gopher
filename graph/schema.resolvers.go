package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.61

import (
	"context"
	"fmt"
	"slices"
	"time"

	"github.com/oxisto/money-gopher/persistence"
)

// Currency is the resolver for the currency field.
func (r *currencyResolver) Currency(ctx context.Context, obj *persistence.Currency) (string, error) {
	panic(fmt.Errorf("not implemented: Currency - currency"))
}

// Security is the resolver for the security field.
func (r *listedSecurityResolver) Security(ctx context.Context, obj *persistence.ListedSecurity) (*persistence.Security, error) {
	return r.DB.GetSecurity(ctx, obj.SecurityID)
}

// LatestQuote is the resolver for the latestQuote field.
func (r *listedSecurityResolver) LatestQuote(ctx context.Context, obj *persistence.ListedSecurity) (*persistence.Currency, error) {
	if obj.LatestQuote.Valid {
		return &persistence.Currency{
			Value:  int32(obj.LatestQuote.Int64),
			Symbol: obj.Currency,
		}, nil
	} else {
		return nil, nil
	}
}

// LatestQuoteTimestamp is the resolver for the latestQuoteTimestamp field.
func (r *listedSecurityResolver) LatestQuoteTimestamp(ctx context.Context, obj *persistence.ListedSecurity) (*string, error) {
	var s string

	if obj.LatestQuoteTimestamp.Valid {
		s = obj.LatestQuoteTimestamp.Time.Format(time.RFC3339)
		return &s, nil
	} else {
		return nil, nil
	}
}

// CreateSecurity is the resolver for the createSecurity field.
func (r *mutationResolver) CreateSecurity(ctx context.Context, input SecurityInput) (*persistence.Security, error) {
	return withTx(r.Resolver, func(qtx *persistence.Queries) (*persistence.Security, error) {
		sec, err := qtx.CreateSecurity(ctx, persistence.CreateSecurityParams{
			ID:          input.ID,
			DisplayName: input.DisplayName,
		})
		if err != nil {
			return nil, err
		}

		for _, listed := range input.ListedAs {
			_, err = qtx.UpsertListedSecurity(ctx, persistence.UpsertListedSecurityParams{
				SecurityID: sec.ID,
				Ticker:     listed.Ticker,
				Currency:   listed.Currency,
			})
			if err != nil {
				return nil, err
			}
		}

		return sec, nil
	})
}

// UpdateSecurity is the resolver for the updateSecurity field.
func (r *mutationResolver) UpdateSecurity(ctx context.Context, id string, input SecurityInput) (*persistence.Security, error) {
	return withTx(r.Resolver, func(qtx *persistence.Queries) (*persistence.Security, error) {
		sec, err := qtx.UpdateSecurity(ctx, persistence.UpdateSecurityParams{
			ID:          id,
			DisplayName: input.DisplayName,
		})
		if err != nil {
			return nil, err
		}

		// Retrieve old listed securities
		oldListed, err := qtx.ListListedSecuritiesBySecurityID(ctx, id)
		if err != nil {
			return nil, err
		}

		// Upsert the new listed securities
		for _, listed := range input.ListedAs {
			_, err = qtx.UpsertListedSecurity(ctx, persistence.UpsertListedSecurityParams{
				SecurityID: sec.ID,
				Ticker:     listed.Ticker,
				Currency:   listed.Currency,
			})
			if err != nil {
				return nil, err
			}

			// Remove the listed security from the old list
			oldListed = slices.DeleteFunc(oldListed, func(ls *persistence.ListedSecurity) bool {
				return ls.Ticker == listed.Ticker
			})
		}

		// Remove the old listed securities
		for _, old := range oldListed {
			_, err = qtx.DeleteListedSecurity(ctx, persistence.DeleteListedSecurityParams{
				SecurityID: sec.ID,
				Ticker:     old.Ticker,
			})
			if err != nil {
				return nil, err
			}
		}

		return sec, nil
	})
}

// TriggerQuoteUpdate is the resolver for the triggerQuoteUpdate field.
func (r *mutationResolver) TriggerQuoteUpdate(ctx context.Context, securityIDs []string) (b bool, err error) {
	err = r.QuoteUpdater.UpdateQuotes(ctx, securityIDs)
	if err != nil {
		return false, err
	}

	return true, nil
}

// Security is the resolver for the security field.
func (r *queryResolver) Security(ctx context.Context, id string) (*persistence.Security, error) {
	return r.DB.GetSecurity(ctx, id)
}

// Securities is the resolver for the securities field.
func (r *queryResolver) Securities(ctx context.Context) ([]*persistence.Security, error) {
	return r.DB.ListSecurities(ctx)
}

// QuoteProvider is the resolver for the quoteProvider field.
func (r *securityResolver) QuoteProvider(ctx context.Context, obj *persistence.Security) (*string, error) {
	if obj.QuoteProvider.Valid {
		return &obj.QuoteProvider.String, nil
	}

	return nil, nil
}

// ListedAs is the resolver for the listedAs field.
func (r *securityResolver) ListedAs(ctx context.Context, obj *persistence.Security) ([]*persistence.ListedSecurity, error) {
	return obj.ListedAs(ctx, r.DB)
}

// Currency returns CurrencyResolver implementation.
func (r *Resolver) Currency() CurrencyResolver { return &currencyResolver{r} }

// ListedSecurity returns ListedSecurityResolver implementation.
func (r *Resolver) ListedSecurity() ListedSecurityResolver { return &listedSecurityResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Security returns SecurityResolver implementation.
func (r *Resolver) Security() SecurityResolver { return &securityResolver{r} }

type currencyResolver struct{ *Resolver }
type listedSecurityResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type securityResolver struct{ *Resolver }
